/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./endTurn.js":
/*!********************!*\
  !*** ./endTurn.js ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.refreshTiles = exports.isTilePlaced = void 0;\nvar main_1 = __webpack_require__(/*! ./main */ \"./main.js\");\nfunction isTilePlaced(cellElement) {\n    return cellElement.childElementCount > 0;\n}\nexports.isTilePlaced = isTilePlaced;\nfunction refreshTiles(containerId, letters) {\n    var container = document.getElementById(containerId);\n    if (!container)\n        return;\n    container.innerHTML = ''; // Clear existing tiles\n    for (var i = 0; i < letters.length; i++) { // Re-create tiles\n        var tile = document.createElement(\"div\");\n        tile.classList.add(\"tile\");\n        tile.id = \"tile-\".concat(containerId, \"-\").concat(i);\n        tile.textContent = letters[i];\n        container.appendChild(tile);\n    }\n    (0, main_1.makeTilesDraggable)(); // Make new tiles draggable\n}\nexports.refreshTiles = refreshTiles;\n\n\n//# sourceURL=webpack:///./endTurn.js?");

/***/ }),

/***/ "./lib/players.js":
/*!************************!*\
  !*** ./lib/players.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateHighscore = exports.getCurrentWord = exports.removeFromCurrentWord = exports.addToCurrentWord = exports.resetCurrentWord = exports.setUserName = exports.resetScores = exports.addPlayerScore = exports.getPlayerScore = exports.player2 = exports.player1 = void 0;\nvar saveData_1 = __webpack_require__(/*! ./saveData */ \"./lib/saveData.js\");\nexports.player1 = {\n    currentScore: 0,\n    user: \"\",\n    currentWords: [],\n};\nexports.player2 = {\n    currentScore: 0,\n    user: \"\",\n    currentWords: [],\n};\nfunction getPlayerScore(player) {\n    return player == 1 ? exports.player1.currentScore : exports.player2.currentScore;\n}\nexports.getPlayerScore = getPlayerScore;\nfunction addPlayerScore(player, addScore) {\n    player == 1\n        ? (exports.player1.currentScore = exports.player1.currentScore + addScore)\n        : (exports.player2.currentScore = exports.player2.currentScore + addScore);\n}\nexports.addPlayerScore = addPlayerScore;\nfunction resetScores() {\n    exports.player1.currentScore = 0;\n    exports.player2.currentScore = 0;\n}\nexports.resetScores = resetScores;\nfunction setUserName(player, userName) {\n    player == 1 ? (exports.player1.user = userName) : (exports.player2.user = userName);\n}\nexports.setUserName = setUserName;\nfunction resetCurrentWord() {\n    exports.player1.currentWords = [];\n    exports.player2.currentWords = [];\n}\nexports.resetCurrentWord = resetCurrentWord;\nfunction addToCurrentWord(player, currentCell) {\n    player == 1\n        ? exports.player1.currentWords.push(currentCell)\n        : exports.player2.currentWords.push(currentCell);\n}\nexports.addToCurrentWord = addToCurrentWord;\nfunction removeFromCurrentWord(player, currentCell) {\n    var playerWord = player == 1 ? exports.player1.currentWords : exports.player2.currentWords;\n    var index = playerWord.indexOf(currentCell);\n    if (index > -1) {\n        playerWord.splice(index, 1);\n    }\n}\nexports.removeFromCurrentWord = removeFromCurrentWord;\nfunction getCurrentWord(player) {\n    return player == 1 ? exports.player1.currentWords : exports.player2.currentWords;\n}\nexports.getCurrentWord = getCurrentWord;\nfunction findUser(userName) {\n    var i = 0;\n    var userArray = (0, saveData_1.getUsers)();\n    while (i < userArray.length) {\n        if (userArray[i].userName == userName) {\n            return userArray[i];\n        }\n    }\n}\nfunction updateHighscore() {\n}\nexports.updateHighscore = updateHighscore;\n\n\n//# sourceURL=webpack:///./lib/players.js?");

/***/ }),

/***/ "./lib/pointCounter.js":
/*!*****************************!*\
  !*** ./lib/pointCounter.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPoints = void 0;\nvar main_1 = __webpack_require__(/*! ../main */ \"./main.js\");\nvar pointList = {\n    a: 1,\n    b: 3,\n    c: 3,\n    d: 2,\n    e: 1,\n    f: 4,\n    g: 2,\n    h: 4,\n    i: 1,\n    j: 8,\n    k: 5,\n    l: 1,\n    m: 3,\n    n: 1,\n    o: 1,\n    p: 3,\n    q: 10,\n    r: 1,\n    s: 1,\n    t: 1,\n    u: 1,\n    v: 4,\n    w: 4,\n    x: 8,\n    y: 4,\n    z: 10,\n};\n/************\n * Gets the points from a specified player the current turn\n * @param  gameBoard the current gameBoard\n * @param player a Player object\n * @invariant player object must contain the the current players words\n * that is on the board for the specific round\n * @returns number of points given for the laid letters\n */\nfunction getPoints(gameBoard, player) {\n    var memoizedCells = [];\n    function treverse(gameBoard, startCell, currentPoints, treverseRowStep, treverseColumnStep, playerCellsFromStart, multiplier) {\n        var startCellChar = startCell.char;\n        var points = 0;\n        var existsInCellsArray = playerCellsFromStart.some(function (item) {\n            return item.row === startCell.row &&\n                item.col === startCell.col &&\n                item.special === startCell.special &&\n                item.char === startCell.char;\n        });\n        if (startCell.special === 3 && existsInCellsArray) {\n            multiplier = 2;\n        }\n        else if (startCell.special === 4 && existsInCellsArray) {\n            multiplier = 3;\n        }\n        if (startCellChar !== \"\") {\n            points =\n                pointList[startCellChar.toLowerCase()] *\n                    multiplier;\n        }\n        if (startCell.special === 1 && existsInCellsArray) {\n            points = points * 2;\n        }\n        else if (startCell.special === 2 && existsInCellsArray) {\n            points = points * 3;\n        }\n        //console.log(\"were on this cell: \", startCell);\n        var existsInMemo = memoizedCells.some(function (item) {\n            return item.row === startCell.row &&\n                item.col === startCell.col &&\n                item.special === startCell.special &&\n                item.char === startCell.char;\n        });\n        //console.log(\"in(true) or not(false) in memory\", existsInMemo);\n        if (existsInMemo) {\n            points = 0;\n        }\n        else {\n            memoizedCells.push(startCell);\n        }\n        var row = startCell.row;\n        var col = startCell.col;\n        //console.log(\"memoized cells: \", memoizedCells);\n        //console.log(\"pointsgivven: \", points);\n        if (row === main_1.outerEdges.maxRow && treverseRowStep > 0) {\n            return points;\n        }\n        if (row === main_1.outerEdges.minRow && treverseRowStep < 0) {\n            return points;\n        }\n        if (col === main_1.outerEdges.maxCol && treverseColumnStep > 0) {\n            return points;\n        }\n        if (col === main_1.outerEdges.minCol && treverseColumnStep < 0) {\n            return points;\n        }\n        if (startCell.char === \"\") {\n            return 0;\n        }\n        else {\n            return (points +\n                treverse(gameBoard, gameBoard[row + treverseRowStep][col + treverseColumnStep], currentPoints + points, treverseRowStep, treverseColumnStep, playerCellsFromStart, multiplier));\n        }\n    }\n    var result = 0;\n    player.currentWords.sort(function (a, b) { return b.special - a.special; });\n    //console.log(player.currentWords);\n    for (var i = 0; i < player.currentWords.length; i++) {\n        var currentPlacedCell = player.currentWords[i];\n        result +=\n            treverse(gameBoard, currentPlacedCell, 0, -1, 0, player.currentWords, 1) +\n                treverse(gameBoard, currentPlacedCell, 0, 1, 0, player.currentWords, 1) +\n                treverse(gameBoard, currentPlacedCell, 0, 0, -1, player.currentWords, 1) +\n                treverse(gameBoard, currentPlacedCell, 0, 0, 1, player.currentWords, 1);\n    }\n    return result;\n}\nexports.getPoints = getPoints;\n\n\n//# sourceURL=webpack:///./lib/pointCounter.js?");

/***/ }),

/***/ "./lib/queue_array.js":
/*!****************************!*\
  !*** ./lib/queue_array.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.display_queue = exports.dequeue = exports.head = exports.enqueue = exports.is_empty = exports.empty = void 0;\n/**\n * Constructs a queue without any elements.\n * @template T type of all queue elements\n * @returns Returns an empty queue.\n */\nfunction empty() {\n    return [0, 0, []];\n}\nexports.empty = empty;\n/**\n * Checks whether a queue is empty.\n * @template T type of all queue elements\n * @param q queue to check for emptiness\n * @returns Returns true, if the queue q has elements, false otherwise.\n */\nfunction is_empty(q) {\n    return q[0] === q[1];\n}\nexports.is_empty = is_empty;\n/**\n * Adds an element to the queue.\n * @template T type of all queue elements\n * @param e element to add\n * @param q queue to modify\n * @modifies q by adding element e to the end\n */\nfunction enqueue(e, q) {\n    var tail_index = q[1];\n    q[2][tail_index] = e;\n    q[1] = tail_index + 1; // update tail index\n}\nexports.enqueue = enqueue;\n/**\n * Retrieves the first element of the queue.\n * @precondition Assumes q to be non-empty\n * @template T type of all queue elements\n * @param q queue to get the first element of\n * @returns Returns the element of the queue that was enqueued first.\n */\nfunction head(q) {\n    var head_index = q[0];\n    return q[2][head_index];\n}\nexports.head = head;\n/**\n * Removes the first element of a queue.\n * @precondition Assumes q to be non-empty\n * @template T type of all queue elements\n * @param q queue to remove the element from\n * @modifies q such that the element that was enqueued first is removed\n */\nfunction dequeue(q) {\n    var head_index = q[0];\n    q[0] = head_index + 1;\n}\nexports.dequeue = dequeue;\n/**\n * Pretty-prints the contents of a queue to standard output.\n * @template T type of all queue elements\n * @param q queue to pretty-print\n */\nfunction display_queue(q) {\n    console.log(q[2].slice(q[0], q[1]));\n}\nexports.display_queue = display_queue;\n\n\n//# sourceURL=webpack:///./lib/queue_array.js?");

/***/ }),

/***/ "./lib/randomLetters.js":
/*!******************************!*\
  !*** ./lib/randomLetters.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateRandomLetters = void 0;\nvar q = __webpack_require__(/*! ./queue_array */ \"./lib/queue_array.js\");\n/**\n * Generates a queue of random letters reflecting the distribution and frequency of letters as specified in the rules of Scrabble.\n * The function creates an array of letters mirroring Scrabble's letter distribution, shuffles this array to randomize the order,\n * and then enqueues each letter into a queue. This simulated bag of letters can then be used for game mechanics,\n * closely mimicking the experience of drawing letter tiles from a bag in a game of Scrabble.\n *\n * @example\n * const letterQueue = generateRandomLetters(); // Returns a queue with letters randomized in accordance with Scrabble distribution.\n *\n * @returns {q.Queue<string>} A queue populated with letters distributed and randomized according to Scrabble rules, ready for gameplay.\n */\nfunction generateRandomLetters() {\n    var letters = [\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"E\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"A\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"I\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"N\",\n        \"N\",\n        \"N\",\n        \"N\",\n        \"N\",\n        \"N\",\n        \"R\",\n        \"R\",\n        \"R\",\n        \"R\",\n        \"R\",\n        \"R\",\n        \"T\",\n        \"T\",\n        \"T\",\n        \"T\",\n        \"T\",\n        \"T\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"L\",\n        \"S\",\n        \"S\",\n        \"S\",\n        \"S\",\n        \"U\",\n        \"U\",\n        \"U\",\n        \"U\",\n        \"D\",\n        \"D\",\n        \"D\",\n        \"D\",\n        \"G\",\n        \"G\",\n        \"G\",\n        \"B\",\n        \"B\",\n        \"C\",\n        \"C\",\n        \"M\",\n        \"M\",\n        \"P\",\n        \"P\",\n        \"F\",\n        \"F\",\n        \"H\",\n        \"H\",\n        \"V\",\n        \"V\",\n        \"W\",\n        \"W\",\n        \"Y\",\n        \"Y\",\n        \"K\",\n        \"J\",\n        \"X\",\n        \"Q\",\n        \"Z\",\n    ];\n    var randomLetters = q.empty();\n    var lettersScrambled = shuffle(letters);\n    for (var i = 0; i < lettersScrambled.length; i++) {\n        q.enqueue(lettersScrambled[i], randomLetters);\n    }\n    return randomLetters;\n}\nexports.generateRandomLetters = generateRandomLetters;\n/**\n * Shuffles the elements of an array in place using the Fisher-Yates shuffle algorithm.\n * his algorithm ensures that each permutation of the array elements is equally likely.\n *\n * @example\n * shuffle([\"A\", \"B\", \"C\", \"D\"]); // might return [\"C\", \"A\", \"D\", \"B\"]\n *\n * @param {Array<string>} array - The array of strings to be shuffled.\n * @returns {Array<string>} Returns the same array with its elements reordered randomly.\n */\nfunction shuffle(array) {\n    var _a;\n    var currentIndex = array.length, randomIndex;\n    // While there remain elements to shuffle.\n    while (currentIndex > 0) {\n        // Pick a remaining element.\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex--;\n        // And swap it with the current element.\n        _a = [\n            array[randomIndex],\n            array[currentIndex],\n        ], array[currentIndex] = _a[0], array[randomIndex] = _a[1];\n    }\n    return array;\n}\n\n\n//# sourceURL=webpack:///./lib/randomLetters.js?");

/***/ }),

/***/ "./lib/saveData.js":
/*!*************************!*\
  !*** ./lib/saveData.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUsers = exports.saveUsers = void 0;\nvar fs = __webpack_require__(/*! fs */ \"?d87b\");\n// npm install -D @types/node\n//fs.readFileSync('users.txt', 'utf8');\nfunction jsonToUserArray(jsonString) {\n    var tempJson = JSON.parse(jsonString);\n    var newArray = [];\n    tempJson.forEach(function (x) {\n        var newElement = JSON.parse(x);\n        var currentIndex = tempJson.indexOf(x);\n        newArray[currentIndex] = newElement;\n    });\n    return newArray;\n}\nfunction userArrayToJson(userArray) {\n    var tempArray = [];\n    userArray.forEach(function (x) {\n        var currentIndex = userArray.indexOf(x);\n        tempArray[currentIndex] = JSON.stringify(x);\n    });\n    return JSON.stringify(tempArray);\n}\nfunction saveUsers(userArray) {\n    fs.writeFile('./users.txt', userArrayToJson(userArray), function (err) {\n        if (err) {\n            throw err;\n        }\n    });\n}\nexports.saveUsers = saveUsers;\nfunction getUsers() {\n    var tempString = fs.readFileSync('./users.txt', 'utf8');\n    return jsonToUserArray(tempString);\n}\nexports.getUsers = getUsers;\n/*\nfunction testing(): void {\n    \n    fs.readFile('./users.txt', (err, data) => {\n        if (err) throw err;\n        tempString.push(data.toString());\n    });\n \n}\n\nlet tempString2: string = \"\"\n\nfetch(\"/users.txt\")\n  .then((response) => response.text())\n  .then((data) => {\n    // Split the data into an array using line breaks\n    const dataArray = data.toString();\n    tempString2 = dataArray;\n  })\n  .catch((error) => console.error(\"Error reading the file:\", error));\n\n\n\nfs.writeFile('./users.txt', \"testarmeragrejernu\", function(err){\n    if (err) {\n        throw err\n    }\n});\n\nlet testingArray: Array<User> = [];\n\nconst user1: User = {userName: \"Anton\", password: \"ost123\", highScore: 700}\nconst user2: User = {userName: \"David\", password: \"tomater\", highScore: 500}\n\ntestingArray[0] = user1;\ntestingArray[1] = user2;\n\nsaveUsers(testingArray);\n*/\n//console.log(tempString2);\n\n\n//# sourceURL=webpack:///./lib/saveData.js?");

/***/ }),

/***/ "./lib/spellChecker.js":
/*!*****************************!*\
  !*** ./lib/spellChecker.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkWordsOnBoard = void 0;\n/**\n * Performs a binary search on a sorted array of strings to find a target word efficiently.\n * This function assumes the dictionary is sorted alphabetically.\n *\n * @example\n * binarySearch([\"apple\", \"banana\", \"cherry\"], \"banana\"); // returns true\n *\n * @param {string[]} dictionary - The sorted array of words to search through.\n * @param {string} target - The word to search for in the dictionary.\n * @returns {boolean} Returns true if the target word is found in the dictionary, otherwise false.\n */\nfunction binarySearch(dictionary, target) {\n    var low = 0;\n    var high = dictionary.length - 1;\n    while (low <= high) {\n        var mid = Math.floor((low + high) / 2);\n        var guess = dictionary[mid];\n        if (guess === target) {\n            return true; // Word found\n        }\n        if (guess < target) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return false; // Word not found\n}\n/**\n * Validates the words formed on the game board against a provided dictionary. It checks both horizontally\n * and vertically formed words, ensuring they are valid and do not consist of isolated letters. Additionally,\n * this function verifies that there are no \"free-floating\" letters on the board, enhancing the game's integrity.\n *\n * @example\n * checkWordsOnBoard(gameBoard, library); // returns true if all words on the board are valid according to the library\n *\n * @param {Array<Array<cell<number, string>>>} gameBoard - The game board represented as a 2D array of cells.\n * @param {string[]} library - A list of valid words used as a reference to validate the words on the board.\n * @returns {boolean} Returns true if all words on the board are valid and there are no isolated letters, otherwise false.\n */\nfunction checkWordsOnBoard(gameBoard, library) {\n    var words = [];\n    // Helper function to get the character at a specific position\n    var getCharAt = function (row, col) {\n        if (row < gameBoard.length && col < gameBoard[row].length) {\n            return gameBoard[row][col].char;\n        }\n        return \"\"; // Return empty string for out-of-bounds\n    };\n    // Improved word collection to avoid adding all subwords indiscriminately\n    for (var row = 0; row < gameBoard.length; row++) {\n        var wordHorizontal = \"\";\n        for (var col = 0; col < gameBoard[row].length; col++) {\n            // Continue building the word if the cell is not empty\n            if (getCharAt(row, col) !== \"\") {\n                wordHorizontal += getCharAt(row, col);\n            }\n            // If the next cell is empty or it's the last cell in the row, and the current word is valid, add it to the list\n            if (getCharAt(row, col + 1) === \"\" || col === gameBoard[row].length - 1) {\n                if (wordHorizontal.length > 1)\n                    words.push(wordHorizontal);\n                wordHorizontal = \"\"; // Reset for the next word\n            }\n        }\n    }\n    // Repeat the same logic for vertical words\n    for (var col = 0; col < gameBoard[0].length; col++) {\n        var wordVertical = \"\";\n        for (var row = 0; row < gameBoard.length; row++) {\n            if (getCharAt(row, col) !== \"\") {\n                wordVertical += getCharAt(row, col);\n            }\n            if (getCharAt(row + 1, col) === \"\" || row === gameBoard.length - 1) {\n                if (wordVertical.length > 1)\n                    words.push(wordVertical);\n                wordVertical = \"\"; // Reset for the next word\n            }\n        }\n    }\n    var hasFreeFlowingLetters = gameBoard.some(function (row, rowIndex) { return row.some(function (cell, colIndex) {\n        if (cell.char !== \"\") { // Check only non-empty cells\n            var adjacentCells = [\n                rowIndex > 0 ? getCharAt(rowIndex - 1, colIndex) : \"\", // Up, check boundary\n                rowIndex < gameBoard.length - 1 ? getCharAt(rowIndex + 1, colIndex) : \"\", // Down, check boundary\n                colIndex > 0 ? getCharAt(rowIndex, colIndex - 1) : \"\", // Left, check boundary\n                colIndex < row.length - 1 ? getCharAt(rowIndex, colIndex + 1) : \"\" // Right, check boundary\n            ];\n            // Check if all adjacent cells are empty (i.e., the letter is free-flowing)\n            return adjacentCells.every(function (adjacent) { return adjacent === \"\"; });\n        }\n        return false; // Skip empty cells\n    }); });\n    if (hasFreeFlowingLetters) {\n        return false; // Invalid board due to a free-flowing letter\n    }\n    console.log(words);\n    // Filter for valid words according to the dictionary\n    var validWords = words.filter(function (word) { return binarySearch(library, word); });\n    // If all collected words are valid, return true; otherwise, false\n    return validWords.length === words.length;\n}\nexports.checkWordsOnBoard = checkWordsOnBoard;\n\n\n//# sourceURL=webpack:///./lib/spellChecker.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeTilesDraggable = exports.outerEdges = void 0;\nvar q = __webpack_require__(/*! ./lib/queue_array */ \"./lib/queue_array.js\");\nvar randomLetters_1 = __webpack_require__(/*! ./lib/randomLetters */ \"./lib/randomLetters.js\");\nvar spellChecker_1 = __webpack_require__(/*! ./lib/spellChecker */ \"./lib/spellChecker.js\");\nvar endTurn_1 = __webpack_require__(/*! ./endTurn */ \"./endTurn.js\");\nvar pointCounter_1 = __webpack_require__(/*! ./lib/pointCounter */ \"./lib/pointCounter.js\");\nvar players_1 = __webpack_require__(/*! ./lib/players */ \"./lib/players.js\");\nexports.outerEdges = { maxRow: 0, minRow: 0, maxCol: 0, minCol: 0 };\nvar submitButton = document.getElementById(\"submitButton\");\nvar changeLettersButton = document.getElementById(\"newLetters\");\nvar passButton = document.getElementById(\"pass\");\nvar gameBoard = [];\nvar roundScore = 0;\nvar turn = 0;\nvar library = [];\nvar leftLetters = \"\";\nvar rightLetters = \"\";\nvar letterQueue = (0, randomLetters_1.generateRandomLetters)();\n//Gets the words from our wordlist.\nfetch(\"lib/Collins Scrabble Words (2019).txt\")\n    .then(function (response) { return response.text(); })\n    .then(function (data) {\n    // Split the data into an array using line breaks\n    var dataArray = data.split(\"\\n\");\n    var cleanedArray = dataArray.map(function (row) { return row.replace(/\\r/g, \"\"); });\n    library = cleanedArray;\n})\n    .catch(function (error) { return console.error(\"Error reading the file:\", error); });\n/**\n * Initializes and displays the game board on the specified HTML element, creating cells based on the given rows and columns. Each cell is represented by a `cell` object and can have special attributes like double letter score, triple letter score, etc., which are visually indicated on the board.\n *\n * @example\n * const boardElement = document.getElementById(\"board\");\n * createBoard(boardElement, 15, 15, gameBoard); // Initializes a 15x15 game board.\n *\n * @param {HTMLElement} boardElement - The HTML element where the board will be displayed.\n * @param {number} rows - The number of rows in the game board.\n * @param {number} cols - The number of columns in the game board.\n * @param {cell<number, string>[][]} board - The game board data structure to be filled with cell objects.\n * @returns {void}\n */\nfunction createBoard(boardElement, rows, cols, board) {\n    for (var row = 0; row < rows; row++) {\n        board.push([]);\n        var _loop_1 = function (col) {\n            board[row].push({ row: row, col: col, special: 0, char: \"\" });\n            var cell = document.createElement(\"div\");\n            var id = String(row + \" \" + col);\n            cell.classList.add(\"cell\");\n            cell.addEventListener(\"dragover\", function (event) {\n                event.preventDefault(); // Allows us to drop.\n                cell.classList.add(\"over\"); // Optional: Visual cue.\n            });\n            cell.addEventListener(\"drop\", function (event) {\n                var _a, _b;\n                event.preventDefault();\n                if (!event.dataTransfer) {\n                    throw new Error(\"event.dataTransfer does not exist\");\n                }\n                var draggableId = event.dataTransfer.getData(\"text\");\n                var draggable = document.getElementById(draggableId);\n                var dropTargetId = (_a = event.target) === null || _a === void 0 ? void 0 : _a.id;\n                if (draggable && cell && cell.childElementCount == 0) {\n                    var tileCharacter_1 = draggable.innerText;\n                    var draggableParentId = (_b = draggable.parentElement) === null || _b === void 0 ? void 0 : _b.id;\n                    // Identify source container and remove character from the corresponding array\n                    if (draggableParentId && draggableParentId.includes(\"leftTiles\")) {\n                        leftLetters = leftLetters\n                            .split(\"\")\n                            .filter(function (c) { return c !== tileCharacter_1; })\n                            .join(\"\");\n                    }\n                    else if (draggableParentId &&\n                        draggableParentId.includes(\"rightTiles\")) {\n                        rightLetters = rightLetters\n                            .split(\"\")\n                            .filter(function (c) { return c !== tileCharacter_1; })\n                            .join(\"\");\n                    }\n                    // Existing logic for handling a successful drop\n                    var onRow = parseInt(dropTargetId.substring(0, dropTargetId.indexOf(\" \")));\n                    var onColl = parseInt(dropTargetId.substring(dropTargetId.lastIndexOf(\" \") + 1));\n                    var gameBoardObjNow = gameBoard[onRow][onColl];\n                    gameBoardObjNow.char = tileCharacter_1;\n                    if (gameBoardObjNow.special !== 0) {\n                        cell.innerText = \"\";\n                    }\n                    if (turn % 2 === 0) {\n                        (0, players_1.addToCurrentWord)(1, gameBoardObjNow);\n                        roundScore = (0, pointCounter_1.getPoints)(gameBoard, players_1.player1);\n                        var player1_score = document.getElementById(\"player1Score\");\n                        if (player1_score)\n                            player1_score.innerText = \"Score: \".concat((0, players_1.getPlayerScore)(1) + roundScore);\n                    }\n                    else {\n                        (0, players_1.addToCurrentWord)(2, gameBoardObjNow);\n                        roundScore = (0, pointCounter_1.getPoints)(gameBoard, players_1.player2);\n                        var player2_score = document.getElementById(\"player2Score\");\n                        if (player2_score)\n                            player2_score.innerText = \"Score: \".concat((0, players_1.getPlayerScore)(2) + roundScore);\n                    }\n                    //console.log(player1.currentWords);\n                    ///console.log(gameBoard);\n                    //console.log(\"after\");\n                    //console.log(\"spellchecking\", checkWordsOnBoard(gameBoard, library));\n                    cell.appendChild(draggable);\n                    cell.classList.remove(\"over\"); // Cleanup visual cue.\n                }\n            });\n            if (speicalSquares[row][col] === 0) {\n                board[row][col].special = 0;\n                boardElement.appendChild(cell);\n                cell.setAttribute(\"id\", id);\n            }\n            else if (speicalSquares[row][col] === 1) {\n                board[row][col].special = 1;\n                cell.setAttribute(\"data-special\", \"double-letter\");\n                cell.setAttribute(\"id\", id);\n            }\n            else if (speicalSquares[row][col] === 2) {\n                board[row][col].special = 2;\n                cell.setAttribute(\"data-special\", \"triple-letter\");\n                cell.setAttribute(\"id\", id);\n            }\n            else if (speicalSquares[row][col] === 3) {\n                board[row][col].special = 3;\n                cell.setAttribute(\"data-special\", \"double-word\");\n                cell.setAttribute(\"id\", id);\n            }\n            else if (speicalSquares[row][col] === 4) {\n                board[row][col].special = 4;\n                cell.setAttribute(\"data-special\", \"triple-word\");\n                cell.setAttribute(\"id\", id);\n            }\n            else if (speicalSquares[row][col] === 5) {\n                board[row][col].special = 5;\n                cell.setAttribute(\"data-special\", \"starting-square\");\n                cell.setAttribute(\"id\", id);\n            }\n            boardElement.appendChild(cell);\n        };\n        for (var col = 0; col < cols; col++) {\n            _loop_1(col);\n        }\n    }\n}\nvar speicalSquares = [\n    [2, 0, 0, 0, 4, 0, 0, 1, 0, 0, 4, 0, 0, 0, 2],\n    [0, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 0],\n    [0, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 0, 3, 0, 0],\n    [0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0],\n    [4, 0, 0, 0, 3, 0, 1, 0, 1, 0, 3, 0, 0, 0, 4],\n    [0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0],\n    [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0],\n    [1, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 3, 0, 0, 1],\n    [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0],\n    [0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0],\n    [4, 0, 0, 0, 3, 0, 1, 0, 1, 0, 3, 0, 0, 0, 4],\n    [0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0],\n    [0, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 0, 3, 0, 0],\n    [0, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 0],\n    [2, 0, 0, 0, 4, 0, 0, 1, 0, 0, 4, 0, 0, 0, 2],\n];\n/**\n * Makes each tile within the game draggable. It sets up drag event listeners on tiles so that they\n * can be moved to different parts of the game board. This function should be called after the tiles\n * are created and rendered on the page.\n *\n * @example\n * makeTilesDraggable(); // Initializes drag functionality for all tiles with the '.tile' class.\n *\n * @returns {void}\n */\nfunction makeTilesDraggable() {\n    // Query all your draggable tiles by a common class or other selector.\n    var tiles = document.querySelectorAll(\".tile\"); // Assuming '.tile' class for your tiles.\n    tiles.forEach(function (tile) {\n        tile.setAttribute(\"draggable\", \"true\");\n        tile.addEventListener(\"dragstart\", function (event) {\n            var DragEvent = event;\n            if (DragEvent.dataTransfer) {\n                DragEvent.dataTransfer.setData(\"text\", tile.id); // Correctly access dataTransfer\n                if (!tile.parentElement) {\n                    throw new Error(\"tile.parentElement does not exist\");\n                }\n                else {\n                    ///////////////////\n                    var dropTargetId = tile.parentElement.id;\n                    var onRow = parseInt(dropTargetId.substring(0, dropTargetId.indexOf(\" \")));\n                    var onColl = parseInt(dropTargetId.substring(dropTargetId.lastIndexOf(\" \") + 1));\n                    var gameBoardObjNow = gameBoard[onRow][onColl];\n                    //////////////////A bunch of garbage code\n                    //console.log(\"before\", gameBoardObjNow);\n                    if (turn % 2 === 0) {\n                        (0, players_1.removeFromCurrentWord)(1, gameBoardObjNow);\n                    }\n                    else {\n                        (0, players_1.removeFromCurrentWord)(2, gameBoardObjNow);\n                    }\n                    //console.log(\"after\", gameBoardObjNow);\n                    gameBoardObjNow.char = \"\";\n                    gameBoardObjNow.special;\n                    //console.log(gameBoard);\n                }\n            }\n        });\n    });\n}\nexports.makeTilesDraggable = makeTilesDraggable;\n/**\n * Creates tile elements for each letter in the provided string and appends them to the specified container element.\n *  Each tile is made draggable and is given a unique ID based on its position and the container it belongs to.\n *\n * @example\n * createTilesForLetters(\"leftTiles\", \"ABCDE\"); // Creates draggable tiles for each letter and\n * appends them to the 'leftTiles' container.\n *\n * @param {string} containerId - The ID of the HTML element where the tiles will be appended.\n * @param {string} letters - A string of letters for which tiles will be created.\n * @returns {void}\n */\nfunction createTilesForLetters(containerId, letters) {\n    var container = document.getElementById(containerId);\n    // Check if the container exists before proceeding.\n    if (!container) {\n        console.error(\"Container with ID \".concat(containerId, \" not found.\"));\n        return; // Exit the function early if container is null.\n    }\n    for (var i = 0; i < letters.length; i++) {\n        var tile = document.createElement(\"div\");\n        tile.classList.add(\"tile\");\n        tile.id = \"tile-\".concat(containerId, \"-\").concat(i);\n        tile.textContent = letters[i];\n        tile.setAttribute(\"draggable\", \"true\");\n        container.appendChild(tile);\n    }\n}\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    var boardElement = document.getElementById(\"board\");\n    if (boardElement) {\n        createBoard(boardElement, 15, 15, gameBoard); // Your existing board creation logic\n        exports.outerEdges = { maxRow: 14, minRow: 0, maxCol: 14, minCol: 0 };\n    }\n    for (var i = 0; i < 7; i++) {\n        leftLetters += q.head(letterQueue);\n        q.dequeue(letterQueue);\n        rightLetters += q.head(letterQueue);\n        q.dequeue(letterQueue);\n    }\n    createTilesForLetters(\"leftTiles\", leftLetters);\n    createTilesForLetters(\"rightTiles\", rightLetters);\n    // Make sure to call this after creating the tiles\n    makeTilesDraggable();\n});\nif (submitButton) {\n    submitButton.addEventListener(\"click\", function () {\n        if ((0, spellChecker_1.checkWordsOnBoard)(gameBoard, library)) {\n            //make laid tiles not movable\n            var tiles = document.querySelectorAll(\".tile\");\n            tiles.forEach(function (tile) {\n                tile.className = \"notMovableEnyMore\";\n                tile.setAttribute(\"draggable\", \"false\");\n            });\n            //Pass on the turn\n            turn++;\n            // Logic to display the correct set of tiles and replenish letters\n            var leftTiles = document.getElementById(\"leftTiles\");\n            var rightTiles = document.getElementById(\"rightTiles\");\n            if (turn % 2 === 0) {\n                //Odd urns are player 2 even are player 1\n                //Add score to player2\n                (0, players_1.addPlayerScore)(2, roundScore);\n                var player2_score = document.getElementById(\"player2Score\");\n                if (player2_score)\n                    player2_score.innerText = \"Score: \".concat((0, players_1.getPlayerScore)(2));\n                //remove current words from player1\n                (0, players_1.resetCurrentWord)();\n                // Hide right tiles, show left tiles\n                if (rightTiles)\n                    rightTiles.style.display = \"none\";\n                if (leftTiles)\n                    leftTiles.style.display = \"block\";\n                // Replenish leftLetters if needed and refresh UI\n                while (leftLetters.length < 7 && !q.is_empty(letterQueue)) {\n                    leftLetters += q.head(letterQueue);\n                    q.dequeue(letterQueue);\n                }\n                (0, endTurn_1.refreshTiles)(\"leftTiles\", leftLetters);\n            }\n            else {\n                //Add score to player1\n                (0, players_1.addPlayerScore)(1, roundScore);\n                var player1_score = document.getElementById(\"player1Score\");\n                if (player1_score)\n                    player1_score.innerText = \"Score: \".concat((0, players_1.getPlayerScore)(1));\n                //remove current words from player1\n                (0, players_1.resetCurrentWord)();\n                // Hide left tiles, show right tiles\n                if (leftTiles)\n                    leftTiles.style.display = \"none\";\n                if (rightTiles)\n                    rightTiles.style.display = \"block\";\n                // Replenish rightLetters if needed and refresh UI\n                while (rightLetters.length < 7 && !q.is_empty(letterQueue)) {\n                    rightLetters += q.head(letterQueue);\n                    q.dequeue(letterQueue);\n                }\n                (0, endTurn_1.refreshTiles)(\"rightTiles\", rightLetters);\n            }\n        }\n    });\n}\nif (changeLettersButton) {\n    changeLettersButton.addEventListener(\"click\", function () {\n        if (turn % 2 === 0) {\n            while (leftLetters.length !== 0) {\n                // Enqueue the last letter of leftLetters into the letterQueue\n                q.enqueue(leftLetters.substring(leftLetters.length - 1), letterQueue);\n                // Remove the last letter from leftLetters\n                leftLetters = leftLetters.substring(0, leftLetters.length - 1);\n            }\n            (0, endTurn_1.refreshTiles)(\"leftTiles\", leftLetters);\n        }\n        else {\n            while (rightLetters.length !== 0) {\n                // Enqueue the last letter of rightLetters into the letterQueue\n                q.enqueue(rightLetters.substring(rightLetters.length - 1), letterQueue);\n                // Remove the last letter from rightLetters\n                rightLetters = rightLetters.substring(0, rightLetters.length - 1);\n            }\n            (0, endTurn_1.refreshTiles)(\"rightTiles\", rightLetters);\n        }\n    });\n}\nif (passButton) {\n    passButton.addEventListener(\"click\", function () {\n        turn++;\n    });\n}\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ }),

/***/ "?d87b":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///fs_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;